x | Implement Users
o | Groundwork on Intro
  x | Create Character that belongs_to :user and :world
  x | Create World with state "turn" and has_one :character and has_one :user
  x | Add belongs_to :worlds and has_many :characters to User
  x | Add a Clickable "Create World" button that creates a new world and character for the user
    x | Add a clickable button
    x | Send request to server
    x | Send AJAX with CSRF token to keep devise happy
    x | Have controller actually create new character and world
  x | Change Page Title
  x | Have front-end state "in world" that it receives from the server if a world exists for user
    x | Return the correct values
    x | Populate the state correctly
  x | When a player refreshes the page and has a World, they should see "World Joined"
    x | Create new Game component
    x | Load menu or game component depending on state of world
    x | Update the front end with a conditional that displays different text when worldExists=true
    x | Break out the "gameState" into it's own generator function in User
    x | Get logic to run a "load initial state" function
    x | Include initial state as a data attribute in the page
    x | Read the data attribute as part of the load initial state action
  x | Fix being not able to destroy worlds, change to world belongs_to :user maybe?
  x | They should see a button that says "Destroy World" that destroys the world and character
    x | Add a dependent: :destroy to remove characters associated with destroyed world
    x | Add logic to destroy world if user destroyed
    x | Create button with action to send destroy world request
    x | Create API endpoint to execute the request and return the new state
  x | Destroying a world causes the page to show the "Create World" option
  x | Create a Region model that can be associated with a world.
    x | A Region has a name and description.
    x | A Region has a has_one relationship to a Character, who now has a belongs_to Region
    x | Destroying a world destroys all associated regions
  x | A Region has connections with other Regions via a model called Paths.
    x | Paths have a unique name, which is a random "Adjective" and "Noun" from a list
    x | Paths belongs_to a World
    x | Paths belongs_to a "startpoint" and an "endpoint" Region
  x | When a world is created, create two Regions, and assign the character to the first region.
    x | Have a path connect the first region to the second
  o | The Descriptions are "There is only Darkness", "There is only Darkness 2"
  o | Regions return a list of "actions" as a type, with names
  o | If there are exit paths, the region has an action {type: :walk, name: "Walk Through Darkness"}
  o | When a player is in a region a region, on the front end, they see its information
    o They see the Region name and description
    o They see the the list of action types as their associated name
  o | Display Action 
    o | Add div with title text "What can I do here?"
    o | Add divs with borders and buttons for each action associated with this region.
  o | Make actions functional
    o | Create action and result chain on front end
    o | Create backend api point
    o | Have logic on back end in response advance the world a turn
    o | Select a path at random to follow
    o | Change character to be associated with the new Region.
  o | Return "changed_region" status along with all details for new region
    o Data for old regions is wiped away by each update - replace, don't combine!
  o | Update front end to reflect.
  o | Create a series of nearly identical regions with descriptions
    o | "You walk through the darkness."
    o | "You find nothing."
    o | "You grow weaker."
    o | "Your steps grow heavy. The darkness clings to you like oil."
    o | "You slow. The darkness rides on your back."
    o | "You are reduced to a crawl."
    o | "You have nothing left."
    o | "You can go no further. You must look inward.‚Äù
  o | Fix error state for when a server request fails to load a world, create an error state perhaps?
  o | Set up Reducer file structure, get it out of configureStore
  o | Split front-end store state into two halfs - clientSide and serverSide. User clientSide for things like isLoaded and serverSide data should never be altered directly by client, just loaded straight from api returns
  o | Create a "waiting/loading" state to use when waiting for feedback from server
  o | Game state doesn't need to return an object called "gameState". It can just return the contents.
  o | Add description progressions.
    o | Default descriptions of rooms should be replaced once things are inside of them.
    o | Add easter egg in the description progression for the initial series of rooms if the player manages to build something in them. "Is this really the wisest idea? You probably shouldn't be doing this."

o | Support Tasks
  o | Switch db to postgres or mysql
  o | Download jsx syntax support for Vim
  o | Get a git repo setup on the shared drive
  x | Recover old project files for reference
  o | Look into reselect
o |
o |
o |
o |
o |
o |
o |
o |
o |
o |
o |
o |
o |
o |
o |
